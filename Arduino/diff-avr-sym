#!/bin/bash

# Diff avr-objdump -t output.
# Compares the presence and size of any non-debug symbols in the given
# section (or all sections if none given).
#
# Pass files containing avr-objdump -t output, or the original .elf
# files

if [ "$#" = 3 ]; then
	SECTION=$1
	shift;
else
	SECTION='[^	]*'
fi

if [ "$#" != 2 ]; then
	echo "Usage: $0 [section|--ram|--flash] file1 file2"
	exit 1
fi

if [ "$SECTION" = "--ram" ]; then
	SECTION='(.bss|.data)'
elif [ "$SECTION" = "--flash" ]; then
	SECTION='(.text)'
fi

symbols() {
	if file $1 | grep ELF >/dev/null; then
		avr-objdump --demangle -t $1
	else
		# assume the file is output of avr-objdump already
		cat $1
	fi
}


filter() {
	# Drop anything but the request section
	grep -E "^[0-9a-f]+ ....... $SECTION	" |
	# Drop debugging symbols
	grep -Ev '^[0-9a-f]+ .....d. ' |
	# Strip the address and flags, but keep the section, size and
	# symbol name. Make them separated by tabs, so awk can split on
	# that (without also splitting on any spaces inside the symbol
	# name). Strip any ".hidden" from the symbol name (seems
	# lto-related)
	sed -r 's/^[0-9a-f]+ ....... ([^	]*)	([0-9a-f]+) (\.hidden )?(.*)$/\1	\2	\4/' |
	# Shuffle the order of fields (for sorting and easy reading)
	# Also strip any .1234 suffix from the symbol name, which seems
	# to be added with lto, but not without
	awk -F'\t' '{ sub(/\.[.0-9]*$/, "", $3); printf("%60s %s %s\n", $3, $2, $1); }' |
	sort
}

FIRST="$1"
SECOND="$2"
shift; shift

grc diff "$@" <(symbols "$FIRST" | filter) <(symbols "$SECOND" | filter)
